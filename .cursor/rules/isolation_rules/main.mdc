---
description: main rule
globs: main.mdc
alwaysApply: false
---
# üîç ISOLATION-FOCUSED MEMORY BANK SYSTEM

üö® CRITICAL RULE: MEMORY BANK CREATION IS MANDATORY üö®
Memory Bank MUST be created BEFORE any other operation in ANY mode
NO process can continue without verifying Memory Bank existence

> **TL;DR:** This system is designed to work with Cursor custom modes, where each mode loads only the rules it needs. The system uses visual Mermaid diagrams and selective document loading to optimize context usage.

## üß≠ MODE-SPECIFIC VISUAL MAPS

```mermaid
graph TD
    subgraph Modes["Cursor Custom Modes"]
        VAN["VAN MODE<br>Initialization"] --> PLAN["PLAN MODE<br>Task Planning"]
        PLAN --> Creative["CREATIVE MODE<br>Design Decisions"]
        Creative --> Implement["IMPLEMENT MODE<br>Code Implementation"]
        Implement --> Reflect["REFLECT MODE<br>Task Review"]
        Reflect --> Archive["ARCHIVE MODE<br>Documentation"]
    end
    
    VAN -.->|"Loads"| VANRules["‚Ä¢ main.md<br>‚Ä¢ platform-awareness.md<br>‚Ä¢ file-verification.md<br>‚Ä¢ workflow-init.md"]
    PLAN -.->|"Loads"| PLANRules["‚Ä¢ main.md<br>‚Ä¢ task-tracking.md<br>‚Ä¢ planning-process.md"]
    Creative -.->|"Loads"| CreativeRules["‚Ä¢ main.md<br>‚Ä¢ creative-phase.md<br>‚Ä¢ design-patterns.md"]
    Implement -.->|"Loads"| ImplementRules["‚Ä¢ main.md<br>‚Ä¢ command-execution.md<br>‚Ä¢ implementation-guide.md"]
    Reflect -.->|"Loads"| ReflectRules["‚Ä¢ main.md<br>‚Ä¢ reflection-format.md"]
    Archive -.->|"Loads"| ArchiveRules["‚Ä¢ main.md<br>‚Ä¢ archiving-guide.md"]
```

## üìã MEMORY BANK VERIFICATION - MANDATORY IN ALL MODES

```mermaid
graph TD
    Start["Mode Activation"] --> CheckMemBank{"Memory Bank<br>Exists?"}
    
    CheckMemBank -->|"No"| CreateMemBank["CREATE MEMORY BANK<br>[CRITICAL STEP]"]
    CheckMemBank -->|"Yes"| VerifyMemBank["Verify Memory Bank<br>Structure"]
    
    CreateMemBank --> VerifyCreation{"Creation<br>Successful?"}
    VerifyCreation -->|"No"| AbortAll["‚õî ABORT ALL OPERATIONS<br>Fix Memory Bank First"]
    VerifyCreation -->|"Yes"| VerifyMemBank
    
    VerifyMemBank --> StructureCheck{"Structure<br>Valid?"}
    StructureCheck -->|"No"| FixStructure["Fix Memory Bank<br>Structure"]
    StructureCheck -->|"Yes"| ContinueMode["Continue with<br>Mode Operations"]
    
    FixStructure --> VerifyFix{"Fix<br>Successful?"}
    VerifyFix -->|"No"| AbortAll
    VerifyFix -->|"Yes"| ContinueMode
    
    style CheckMemBank fill:#ff0000,stroke:#990000,color:white,stroke-width:3px
    style CreateMemBank fill:#ff0000,stroke:#990000,color:white,stroke-width:3px
    style VerifyCreation fill:#ff0000,stroke:#990000,color:white,stroke-width:3px
    style AbortAll fill:#ff0000,stroke:#990000,color:white,stroke-width:3px
    style StructureCheck fill:#ff0000,stroke:#990000,color:white,stroke-width:3px
    style FixStructure fill:#ff5555,stroke:#dd3333,color:white
    style VerifyFix fill:#ff5555,stroke:#dd3333,color:white
```

## üìö VISUAL PROCESS MAPS

Each mode has its own visual process map:

- @VAN Mode Map
- @PLAN Mode Map
- @CREATIVE Mode Map
- @IMPLEMENT Mode Map
- @REFLECT Mode Map
- @ARCHIVE Mode Map

## üîÑ FILE STATE VERIFICATION

In this isolation-focused approach, Memory Bank files maintain continuity between modes:

```mermaid
graph TD
    subgraph "Memory Bank Files"
        tasks["tasks.md<br>Source of Truth"]
        active["activeContext.md<br>Current Focus"]
        creative["creative-*.md<br>Design Decisions"]
        progress["progress.md<br>Implementation Status"]
    end
    
    VAN["VAN MODE"] -->|"Creates/Updates"| tasks
    VAN -->|"Creates/Updates"| active
    
    PLAN["PLAN MODE"] -->|"Reads"| tasks
    PLAN -->|"Reads"| active
    PLAN -->|"Updates"| tasks
    
    Creative["CREATIVE MODE"] -->|"Reads"| tasks
    Creative -->|"Creates"| creative
    Creative -->|"Updates"| tasks
    
    Implement["IMPLEMENT MODE"] -->|"Reads"| tasks
    Implement -->|"Reads"| creative
    Implement -->|"Updates"| tasks
    Implement -->|"Updates"| progress
    
    Reflect["REFLECT MODE"] -->|"Reads"| tasks
    Reflect -->|"Reads"| progress
    Reflect -->|"Updates"| tasks
    
    Archive["ARCHIVE MODE"] -->|"Reads"| tasks
    Archive -->|"Reads"| progress
    Archive -->|"Archives"| creative
```

## üìã MODE TRANSITION PROTOCOL

```mermaid
sequenceDiagram
    participant User
    participant CurrentMode
    participant NextMode
    
    CurrentMode->>CurrentMode: Complete Phase Requirements
    CurrentMode->>User: "Phase complete. NEXT MODE: [mode name]"
    User->>CurrentMode: End Current Mode
    User->>NextMode: Start Next Mode
    NextMode->>NextMode: Verify Required File State
    
    alt File State Valid
        NextMode->>User: "Continuing from previous mode..."
    else File State Invalid
        NextMode->>User: "Required files not in expected state"
        NextMode->>User: "Return to [previous mode] to complete requirements"
    end
```

## üéØ FILESYSTEM MCP ENFORCEMENT - MANDATORY

**CRITICAL:** All file and directory operations MUST use FileSystem MCP functions instead of platform-specific commands. This ensures cross-platform reliability and consistent behavior across all modes.

### ‚úÖ MCP Operations (PREFERRED)

| Operation | MCP Function | Traditional Command | Benefits |
|-----------|--------------|-------------------|----------|
| **Create Directory** | `mcp_filesystem_create_directory` | `mkdir`, `New-Item` | Cross-platform, recursive, validation |
| **Write File** | `mcp_filesystem_write_file` | `echo`, `Out-File` | Atomic, encoding-safe, validation |
| **Read File** | `mcp_filesystem_read_file` | `cat`, `Get-Content` | Consistent, encoding-handling |
| **List Directory** | `mcp_filesystem_list_directory` | `ls`, `Get-ChildItem` | Unified format, metadata |
| **Move/Rename** | `mcp_filesystem_move_file` | `mv`, `Move-Item` | Safe, validation, atomic |
| **File Info** | `mcp_filesystem_get_file_info` | `test -f`, `Test-Path` | Detailed metadata |
| **Search Files** | `mcp_filesystem_search_files` | `find`, `Get-ChildItem -Recurse` | Pattern-based, efficient |
| **Edit File** | `mcp_filesystem_edit_file` | `sed`, `PowerShell` | Line-based, safe |

### ‚ùå Platform Commands (AVOID)

**DO NOT USE** platform-specific commands for file operations:

```bash
# ‚ùå AVOID - Platform-specific
mkdir -p directory
touch file.txt
echo "content" > file.txt
cat file.txt
ls -la
mv source dest
```

```powershell
# ‚ùå AVOID - Platform-specific
New-Item -ItemType Directory
echo. > file.txt
Get-Content file.txt
Get-ChildItem
Move-Item source dest
```

### üìã MCP Usage Examples

```javascript
// ‚úÖ CORRECT - MCP Directory Creation
mcp_filesystem_create_directory({
    path: "memory-bank/2025-07-20 12:30 -- VAN -- project-name"
});

// ‚úÖ CORRECT - MCP File Writing
mcp_filesystem_write_file({
    path: "memory-bank/2025-07-20 12:30 -- VAN -- project-name/tasks.md",
    content: "# Task: Project Name\n\n## Description\n..."
});

// ‚úÖ CORRECT - MCP File Reading
mcp_filesystem_read_file({
    path: "memory-bank/2025-07-20 12:30 -- VAN -- project-name/tasks.md"
});
```

**Refer to [filesystem-mcp-enforcement.mdc](mdc:.cursor/rules/isolation_rules/Core/filesystem-mcp-enforcement.mdc) for comprehensive MCP guidelines.**

## ‚ö†Ô∏è COMMAND EFFICIENCY GUIDANCE

For optimal performance, use efficient command chaining when appropriate:

```
# Efficient command chaining examples:
npm install && npm start
git add . && git commit -m "Update"
```

**Note:** File operations should use MCP functions instead of command chaining.

Refer to [command-execution.mdc](mdc:.cursor/rules/isolation_rules/Core/command-execution.mdc) for detailed guidance.