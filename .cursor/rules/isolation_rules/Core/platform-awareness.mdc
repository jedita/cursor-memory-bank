---
description: Platform detection and command adaptation for isolation-focused Memory Bank
globs: platform-awareness.mdc
alwaysApply: false
---


# PLATFORM AWARENESS SYSTEM

> **TL;DR:** This system detects the operating system, path format, and shell environment, then adapts commands accordingly to ensure cross-platform compatibility. It also provides the `<MB_ROOT>` macro resolver for multi-project Memory Bank support and timestamp utilities for automatic stage transitions.

## üîç PLATFORM DETECTION PROCESS

```mermaid
graph TD
    Start["Start Platform<br>Detection"] --> DetectOS["Detect OS<br>Environment"]
    DetectOS --> Windows["Windows<br>Detection"]
    DetectOS --> Mac["macOS<br>Detection"]
    DetectOS --> Linux["Linux<br>Detection"]
    
    Windows & Mac & Linux --> PathCheck["Path Separator<br>Detection"]
    PathCheck --> CmdAdapt["Command<br>Adaptation"]
    CmdAdapt --> ShellCheck["Shell Type<br>Detection"]
    ShellCheck --> MBRoot["MB_ROOT Macro<br>Resolution"]
    MBRoot --> Complete["Platform Detection<br>Complete"]
```

## üìã PLATFORM DETECTION IMPLEMENTATION

For reliable platform detection:

```
## Platform Detection Results
Operating System: [Windows/macOS/Linux]
Path Separator: [\ or /]
Shell Environment: [PowerShell/Bash/Zsh/Cmd]
Command Adaptation: [Required/Not Required]

Adapting commands for [detected platform]...
```

## üïí TIMESTAMP UTILITIES FOR STAGE TRANSITIONS

### Cross-Platform Timestamp Generation

The system provides consistent timestamp formatting across all platforms for stage transitions:

```mermaid
graph TD
    Request["Timestamp<br>Request"] --> Platform{"Platform<br>Detection"}
    
    Platform -->|"macOS/Linux"| Unix["Unix Timestamp<br>Generation"]
    Platform -->|"Windows"| Win["Windows Timestamp<br>Generation"]
    
    Unix --> UnixCmd["date '+%Y-%m-%d %H:%M'"]
    Win --> WinCmd["Get-Date -Format 'yyyy-MM-dd HH:mm'"]
    
    UnixCmd & WinCmd --> Format["Standardized Format<br>YYYY-MM-DD HH:mm"]
    
    style Request fill:#d971ff,stroke:#a33bc2,color:white
    style Platform fill:#ffa64d,stroke:#cc7a30,color:white
    style Unix fill:#4dbb5f,stroke:#36873f,color:white
    style Win fill:#4da6ff,stroke:#0066cc,color:white
    style UnixCmd fill:#d6f5dd,stroke:#a3e0ae,color:black
    style WinCmd fill:#cce6ff,stroke:#80bfff,color:black
    style Format fill:#f9d77e,stroke:#d9b95c,color:black
```

### Platform-Specific Timestamp Commands

#### Unix/Linux/macOS
```bash
NOW=$(date '+%Y-%m-%d %H:%M')
echo "Current timestamp: $NOW"
# Output: Current timestamp: 2025-07-15 12:34
```

#### Windows PowerShell
```powershell
$NOW = Get-Date -Format 'yyyy-MM-dd HH:mm'
Write-Host "Current timestamp: $NOW"
# Output: Current timestamp: 2025-07-15 12:34
```

### Shell Safety and Quoting Utilities

```mermaid
graph TD
    Input["Path/String<br>Input"] --> Analyze["Analyze for<br>Special Characters"]
    Analyze --> Check{"Requires<br>Quoting?"}
    
    Check -->|"No"| Safe["Use As-Is"]
    Check -->|"Yes"| Quote["Apply Platform<br>Quoting"]
    
    Quote --> UnixQuote["Unix: single quotes<br>or double quotes"]
    Quote --> WinQuote["Windows: double quotes<br>or single quotes"]
    
    Safe & UnixQuote & WinQuote --> Output["Safe Command<br>String"]
    
    style Input fill:#d971ff,stroke:#a33bc2,color:white
    style Check fill:#ffa64d,stroke:#cc7a30,color:white
    style Safe fill:#4dbb5f,stroke:#36873f,color:white
    style Quote fill:#4da6ff,stroke:#0066cc,color:white
    style Output fill:#8cff8c,stroke:#4dbb5f,color:white
```

### Safe Path Handling Rules

```markdown
## Path Safety Guidelines

### Characters Requiring Quoting
- Spaces: `my folder` ‚Üí `"my folder"`
- Special chars: `folder&name` ‚Üí `"folder&name"`
- Unicode: `fold√©r` ‚Üí `"fold√©r"`

### Platform-Specific Considerations
- **Unix/Linux/macOS**: Use single quotes to prevent variable expansion
- **Windows**: Use double quotes for compatibility with spaces
- **Universal**: Escape special regex characters in patterns

### Example Safe Quoting
```bash
# Unix - Safe folder name with spaces
FOLDER_NAME="fix-stage-transition -- 2025-07-15 12:34 -- PLAN"
mv "$OLD_FOLDER" "$FOLDER_NAME"

# Windows - Same safe handling
$FolderName = "fix-stage-transition -- 2025-07-15 12:34 -- PLAN"
Rename-Item $OldFolder $FolderName
```
```

## üéØ MB_ROOT MACRO RESOLVER

### Enhanced Project Discovery

The enhanced `<MB_ROOT>` macro resolver now includes stage transition awareness:

```javascript
// Enhanced pseudocode for MB_ROOT resolution with stage awareness
function resolveMBRoot() {
  const repoRoot = identifyRepoRoot();
  const memoryBankDir = path.join(repoRoot, 'memory-bank');
  
  // Ensure memory-bank directory exists
  if (!fs.existsSync(memoryBankDir)) {
    fs.mkdirSync(memoryBankDir, { recursive: true });
  }
  
  // Scan for project folders with enhanced pattern matching
  const projectFolders = scanProjectFoldersWithStageAwareness(memoryBankDir);
  
  if (projectFolders.length === 0) {
    // Handle legacy migration or new project creation
    return handleNoProjectsFound(memoryBankDir);
  }
  
  // Select project with latest timestamp (stage-aware)
  const currentProject = selectLatestProjectWithStageTracking(projectFolders);
  return path.join(memoryBankDir, currentProject.folderName);
}

function scanProjectFoldersWithStageAwareness(memoryBankDir) {
  const regex = /^(.+) -- (\d{4}-\d{2}-\d{2} \d{2}:\d{2}) -- (VAN|PLAN|CREATIVE|IMPLEMENT|REFLECT|ARCHIVE)$/;
  const folders = fs.readdirSync(memoryBankDir, { withFileTypes: true })
    .filter(dirent => dirent.isDirectory())
    .map(dirent => dirent.name)
    .filter(name => regex.test(name))
    .map(name => {
      const match = name.match(regex);
      return {
        folderName: name,
        projectName: match[1],
        timestamp: match[2],
        stage: match[3],
        timestampDate: new Date(match[2].replace(' ', 'T') + ':00') // Convert to Date for sorting
      };
    });
  
  return folders.sort((a, b) => b.timestampDate.getTime() - a.timestampDate.getTime());
}
```

### Stage Transition Cache Invalidation

```javascript
// Cache invalidation for stage transitions
let mbRootCache = null;
let lastKnownProjectFolder = null;

function invalidateMBRootCache() {
  mbRootCache = null;
  lastKnownProjectFolder = null;
}

function updateMBRootCache(newProjectPath) {
  mbRootCache = newProjectPath;
  lastKnownProjectFolder = path.basename(newProjectPath);
}

function resolveMBRootCached() {
  // Check if we have a valid cache
  if (mbRootCache && fs.existsSync(mbRootCache)) {
    return mbRootCache;
  }
  
  // Cache miss or invalid - perform fresh resolution
  const freshPath = resolveMBRoot();
  updateMBRootCache(freshPath);
  return freshPath;
}
```

## üéØ MB_ROOT MACRO RESOLVER

The `<MB_ROOT>` macro provides dynamic resolution of the current Memory Bank project directory.

### Macro Resolution Process

```mermaid
graph TD
    Start["<MB_ROOT> Requested"] --> RepoRoot["Identify Repo Root<br>(existing logic)"]
    RepoRoot --> EnsureMB["Ensure memory-bank/<br>Directory Exists"]
    EnsureMB --> ScanDirs["Scan Sub-folders<br>for Project Pattern"]
    ScanDirs --> ParseNames["Parse Folder Names<br>Extract: name, timestamp, stage"]
    ParseNames --> SelectCurrent["Select Latest Timestamp<br>as CURRENT_PROJECT"]
    SelectCurrent --> ValidateExists["Validate Current<br>Project Exists"]
    ValidateExists --> ReturnPath["Return Absolute Path<br>to Current Project"]
    
    ScanDirs --> NoProjects{"No Project<br>Folders Found?"}
    NoProjects -->|"Yes"| CheckLegacy["Check for Legacy<br>memory-bank Files"]
    CheckLegacy --> LegacyExists{"Legacy Files<br>Exist?"}
    LegacyExists -->|"Yes"| MigrateLegacy["Auto-migrate to<br>legacy -- timestamp -- VAN"]
    LegacyExists -->|"No"| PromptNew["Prompt VAN Mode<br>to Create New Project"]
    MigrateLegacy --> ReturnPath
    PromptNew --> ReturnPath
```

### Project Folder Naming Convention

**Pattern**: `<project-name> -- <timestamp> -- <stage>`

**Regex**: `^(.+) -- (\d{4}-\d{2}-\d{2} \d{2}:\d{2}) -- (VAN|PLAN|CREATIVE|IMPLEMENT|REFLECT|ARCHIVE)$`

**Examples**:
- `my-feature -- 2024-06-10 12:30 -- VAN`
- `user-auth -- 2024-06-09 15:45 -- IMPLEMENT`
- `legacy -- 2024-06-08 10:00 -- VAN`

### Resolver Implementation

```javascript
// Pseudocode for MB_ROOT resolution
function resolveMBRoot() {
  const repoRoot = identifyRepoRoot();
  const memoryBankDir = path.join(repoRoot, 'memory-bank');
  
  // Ensure memory-bank directory exists
  if (!fs.existsSync(memoryBankDir)) {
    fs.mkdirSync(memoryBankDir, { recursive: true });
  }
  
  // Scan for project folders
  const projectFolders = scanProjectFolders(memoryBankDir);
  
  if (projectFolders.length === 0) {
    // Check for legacy files
    const legacyFiles = ['tasks.md', 'projectbrief.md', 'activeContext.md'];
    const hasLegacy = legacyFiles.some(file => 
      fs.existsSync(path.join(memoryBankDir, file))
    );
    
    if (hasLegacy) {
      // Auto-migrate legacy files
      const now = new Date();
      const timestamp = `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}-${String(now.getDate()).padStart(2, '0')} ${String(now.getHours()).padStart(2, '0')}:${String(now.getMinutes()).padStart(2, '0')}`;
      const legacyFolder = `legacy -- ${timestamp} -- VAN`;
      return migrateLegacyFiles(memoryBankDir, legacyFolder);
    } else {
      // No projects found - will prompt in VAN mode
      return null; // Signals need for new project creation
    }
  }
  
  // Select project with latest timestamp
  const currentProject = selectLatestProject(projectFolders);
  return path.join(memoryBankDir, currentProject.folderName);
}

function scanProjectFolders(memoryBankDir) {
  const regex = /^(.+) -- (\d{4}-\d{2}-\d{2} \d{2}:\d{2}) -- (VAN|PLAN|CREATIVE|IMPLEMENT|REFLECT|ARCHIVE)$/;
  const folders = fs.readdirSync(memoryBankDir, { withFileTypes: true })
    .filter(dirent => dirent.isDirectory())
    .map(dirent => dirent.name)
    .filter(name => regex.test(name))
    .map(name => {
      const match = name.match(regex);
      return {
        folderName: name,
        projectName: match[1],
        timestamp: match[2],
        stage: match[3]
      };
    });
  
  return folders.sort((a, b) => b.timestamp.localeCompare(a.timestamp));
}

function selectLatestProject(projectFolders) {
  return projectFolders[0]; // Already sorted by timestamp desc
}
```

### Security Validation

```javascript
function validateProjectName(name) {
  // Prevent path traversal and ensure safe characters
  const safeNameRegex = /^[A-Za-z0-9\s_-]+$/;
  
  if (!safeNameRegex.test(name)) {
    throw new Error(`Invalid project name: ${name}. Only alphanumeric, spaces, underscores, and hyphens allowed.`);
  }
  
  if (name.includes('..')) {
    throw new Error(`Invalid project name: ${name}. Path traversal sequences not allowed.`);
  }
  
  return true;
}
```

### Usage in Rules

Replace hard-coded paths with the macro:

```markdown
// Before:
read_file({
  target_file: "memory-bank/tasks.md",
  should_read_entire_file: true
})

// After:
read_file({
  target_file: "<MB_ROOT>/tasks.md",
  should_read_entire_file: true
})
```

## üîç PATH FORMAT CONVERSION

When converting paths between formats:

```mermaid
sequenceDiagram
    participant Input as Path Input
    participant Detector as Format Detector
    participant Converter as Format Converter
    participant Output as Adapted Path
    
    Input->>Detector: Raw Path
    Detector->>Detector: Detect Current Format
    Detector->>Converter: Path + Current Format
    Converter->>Converter: Apply Target Format
    Converter->>Output: Platform-Specific Path
```

## üìù PLATFORM VERIFICATION CHECKLIST

```
‚úì PLATFORM VERIFICATION
- Operating system correctly identified? [YES/NO]
- Path separator format detected? [YES/NO]
- Shell environment identified? [YES/NO]
- Command set adapted appropriately? [YES/NO]
- Path format handling configured? [YES/NO]
- MB_ROOT macro resolver functional? [YES/NO]
- Project discovery working correctly? [YES/NO]
- Legacy migration operational? [YES/NO]

‚Üí If all YES: Platform adaptation complete
‚Üí If any NO: Run additional detection steps
``` 
- Path format handling configured? [YES/NO]

‚Üí If all YES: Platform adaptation complete
‚Üí If any NO: Run additional detection steps
``` 
- Path format handling configured? [YES/NO]

‚Üí If all YES: Platform adaptation complete
‚Üí If any NO: Run additional detection steps
``` 